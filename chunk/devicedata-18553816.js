var X=Object.defineProperty;var q=(f,g,e)=>g in f?X(f,g,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[g]=e;var w=(f,g,e)=>(q(f,typeof g!="symbol"?g+"":g,e),e),j=(f,g,e)=>{if(!g.has(f))throw TypeError("Cannot "+e)};var p=(f,g,e)=>(j(f,g,"read from private field"),e?e.call(f):g.get(f)),C=(f,g,e)=>{if(g.has(f))throw TypeError("Cannot add the same private member more than once");g instanceof WeakSet?g.add(f):g.set(f,e)},R=(f,g,e,t)=>(j(f,g,"write to private field"),t?t.call(f,e):g.set(f,e),e);import{bF as H,bG as W,bc as E,bu as b,br as z,bH as J,bt as Q}from"../assets/index-83a10b2e.js";import{q as V,s as D,e as F,b as Z,m as K,B as ee,j as te,i as se,a as k}from"./xcs-canvas-5c2592d6.js";import{b as ae,n as ie}from"./xcs-vue-family-70642f71.js";const{LASER_CYLINDER:ne}=b,{FILL_VECTOR_ENGRAVING:re}=z,{BITMAP:U}=Q;var P,N,m,L,x,A,M,S,I,$,v;class de extends H.EventEmitter{constructor(e,t,i,s,a){super();C(this,L);C(this,I);w(this,"data",ae(new Map));C(this,P,void 0);C(this,N,W);C(this,m,void 0);C(this,A,void 0);C(this,M,void 0);C(this,S,void 0);C(this,v,3.1416);R(this,P,e),R(this,m,t),R(this,A,i),R(this,M,s),R(this,S,a)}get processingModes(){return V(p(this,A))?p(this,A).call(this):p(this,A)}get processingTypes(){return V(p(this,M))?p(this,M).call(this):p(this,M)}created({canvasList:e}){console.log(["=> DeviceData created"],e),e.forEach(t=>{const i=this.onAddCanvas(t.id),{mode:s,data:a}=i,r=a[s].material||0,n=this.createDisplays({mode:s,displays:t.displays,displaysData:i.displays,material:r});this.emit(E.UPDATE_DISPLAYS_STATUS,{canvasId:t.id,data:n})})}clear(){this.data.value.clear(),console.log(["=> clear",this.data.value])}dispose(){this.removeAllListeners()}createDisplays({mode:e,displays:t,displaysData:i,material:s=0,materialList:a=[]}){console.log(["=> createDisplays"],{displays:t,material:s,materialList:a});const r=[];return t.forEach(n=>{const{id:c,type:o,processingType:h}=n,l=a.find(_=>_.id===s),d=s>0&&!se(l),u="customize",y=p(this,N).processingData,T=o!==U?{VECTOR_CUTTING:{materialType:u,parameter:{customize:{...y.VECTOR_CUTTING}}},VECTOR_ENGRAVING:{materialType:u,parameter:{customize:{...y.VECTOR_ENGRAVING}}},FILL_VECTOR_ENGRAVING:{materialType:u,parameter:{customize:{...y.FILL_VECTOR_ENGRAVING}}}}:{BITMAP_ENGRAVING:{materialType:u,parameter:{customize:{...y.BITMAP_ENGRAVING}}}};d&&Object.keys(l.processingData).forEach(_=>{D(T,`${_}.materialType`,"official"),D(T,`${_}.parameter.official`,{...y[_],...l.processingData[_]})});const G=this.getDeviceModeData(e).processingTypes,O=o===U?"BITMAP_ENGRAVING":G.includes(h)?h:G[0],{color:B,isFill:Y}=this.getProcessTypeData(O);r.push({id:c,config:{lineColor:B,fillColor:B,isFill:Y}}),i.set(c,{processingType:O,data:T,type:o,isFill:Y,processIgnore:!1})}),r}onAddCanvas(e){const t=b.LASER_PLANE,i={mode:t,data:{[t]:{...p(this,P)[t]}},displays:new Map};return this.data.value.set(e,i),this.updateProcessingArea(e,t),this.updateCanvasInitStatus(e,t),this.initCylinder(this.data.value.get(e)),i}onImportData(e){console.log(["=> onImportData"]),e.forEach((t,i)=>{this.updateProcessingArea(i,t.mode),this.updateCanvasInitStatus(i,t.mode,!1),t.displays.forEach(s=>{let a=!1;for(i in s.data)if(s.data[i].processIgnore){a=!0;break}a&&(s.processIgnore=!0)})}),this.data.value=e}getCurrentCanvasData(e,t){const i=this.data.value.get(e);return i&&t&&t(i),i}getCurrentDeviceModeData(e){const t=p(this,I,$).data.find(a=>a.key===e)||p(this,I,$).base,i=this.processingModes.find(a=>a.value===e)||{};return Object.assign({},t,i)}getCurrentCanvasDeviceModeData(e){const t=this.data.value.get(e);return this.getCurrentDeviceModeData(t.mode)}updateProcessingArea(e,t){const{width:i,height:s,angle:a,offsetX:r,offsetY:n}=this.getCurrentDeviceModeData(t);this.emit(E.UPDATE_PROCESSING_AREA,{canvasId:e,option:{width:i,height:s,angle:a,offsetX:r,offsetY:n}})}updateCurvePreviewDisabled(e){e!==b.CURVE_PROCESS&&this.emit(E.UPDATE_CURVE_PREVIEW_DISABLED,!0)}updateCanvasInitStatus(e,t,i=!0){const s=this.processingModes.find(a=>a.value===t);if(s){const a=s.processingTypes.slice(0).shift(),r=this.processingTypes.find(n=>n.type===a);r&&this.emit(E.UPDATE_CANVAS_INIT_STATUS,{canvasId:e,config:{enableFill:s.processingTypes.some(n=>n===re),updateCanvasDisplay:i,isFill:r.isFill,fillColor:r.color,lineColor:r.color}})}}onDelCanvas(e){this.data.value.delete(e)}onAddCanvasDisplays(e,t,i){const s=this.data.value.get(e);if(s){const{mode:a,data:r}=s,n=r[a].material||0;this.createDisplays({mode:a,displays:t,material:n,displaysData:s.displays,materialList:i})}}onCopyDisplays(e){const t={canvasId:"",displays:[],value:z.VECTOR_ENGRAVING};e.forEach(({source:i,target:s})=>{const a=this.data.value.get(i.canvasId);if(a){const r=F(a.displays.get(i.displayId));r&&s.forEach(n=>{const c=this.data.value.get(n.canvasId);if(c){const{mode:o}=c,h=r.processingType,l=this.getDeviceModeData(o).processingTypes||[];!l.includes(h)&&!Z(l)&&r.type!==U&&(t.displays.push(n.displayId),t.canvasId=n.canvasId,t.value=l[0]),c.displays.set(n.displayId,F(r))}})}}),this.onProcessingTypeChange(t)}onDelCanvasDisplays(e,t){const i=this.data.value.get(e);i&&t.forEach(s=>{i.displays.delete(s.id)})}onDeviceModeChange(e,t,i){const s=this.data.value.get(e);s&&(this.materialChangeByMode(s,t,i),this.processTypeChangeByMode(e,t),this.speedScopeChange(e,t,!1),D(s,"mode",t),this.updateProcessingArea(e,t),this.initCylinder(s),this.updateCurvePreviewDisabled(t))}onProcessingTypeChange({canvasId:e,displays:t,value:i,isUpdateSelected:s=!1}){const a=this.data.value.get(e);if(a){const r=t.map(n=>{const c=a.displays.get(n);if(c){D(c,"processingType",i);const o=this.getProcessTypeData(i);if(o!=null&&o.type){const h={lineColor:o.color,fillColor:o.color,isFill:o.isFill};return{id:n,config:h}}return}}).filter(n=>n);s?this.emit(E.UPDATE_SELECTED_ATTR_STATUS,{canvasId:e,data:r}):this.emit(E.UPDATE_DISPLAYS_STATUS,{canvasId:e,data:r})}}onProcessIgnoreChange({canvasId:e,displays:t,value:i}){const s=this.data.value.get(e);s&&t.forEach(a=>{const r=s.displays.get(a);r&&D(r,"processIgnore",!i)})}onXtoolSelectedChange({canvasId:e,displays:t,type:i,value:s}){const a=this.data.value.get(e);a&&t.forEach(r=>{const n=a.displays.get(r);n&&D(n,`data.${i}.materialType`,s)})}onLayerDataChange({canvasId:e,displays:t,materialType:i,type:s,id:a,value:r}){const n=this.data.value.get(e);n&&t.forEach(c=>{const o=n.displays.get(c);o&&(a==="materialType"?D(o,`data.${s}.materialType`,r):D(o,`data.${s}.parameter.${i}.${a}`,r))})}calMaxSpeed({maxValue:e,mode:t,rotaryAttachmentType:i,diameter:s}){const a=localStorage.getItem("MAX_SPEED");return a&&!isNaN(Number(a))?Number(a):K(e)?e:{LASER_CYLINDER:e(i,s)}[t]}getMaxSpeed(e,t){const i=this.data.value.get(e);if(i){const{mode:s,data:a}=i,r=ee([b.LASER_CYLINDER,b.LASER_CONVEYOR_FEEDER],s)?s:"DEFAULT",{diameter:n,rotaryAttachmentType:c}=this.getDiameterAndRotaryAttachmentType({mode:s,generalData:a});return this.calMaxSpeed({maxValue:p(this,L,x)[r][t].max,mode:s,diameter:n,rotaryAttachmentType:c})}}getNextMaterialList(e,t){var a;const i=(a=this.getDeviceModeData(e))==null?void 0:a.processingTypes;return this.getSupportMaterialList(i,t)}getCurrentMaterialData(e,t){var r,n;let i=0,s=p(this,N).processingData;const a=this.data.value.get(e);if(a){const{data:c,mode:o}=a,h=((r=c[o])==null?void 0:r.material)||0;if(h>0){i=h;const l=(n=this.getDeviceModeData(o))==null?void 0:n.processingTypes,u=this.getSupportMaterialList(l,t).find(y=>y.id===i);u?s=u.processingData:s={}}}return{materialId:i,processingData:s}}onMaterialChange(e,t,i){const s=this.data.value.get(e);if(s){const{mode:a}=s;D(s,`data.${a}.material`,t),ie(()=>{var c;const r=(c=this.getDeviceModeData(a))==null?void 0:c.processingTypes,n=this.getSupportMaterialList(r,i).find(o=>o.id===t);n&&(this.speedScopeChange(e,a,!0,n),D(s,`data.${a}.thickness`,n==null?void 0:n.thickness),D(s,`data.${a}.diameter`,n!=null&&n.diameter?n.diameter:null),D(s,`data.${a}.perimeter`,n!=null&&n.perimeter?n.perimeter:s.data[a].diameter?s.data[a].diameter*p(this,v):null))})}}needShowCylinder(e){return(this.processingModes.find(t=>t.value===e)||{hasCylinder:!1}).hasCylinder}initCylinder(e){const{mode:t}=e,i=p(this,I,$).data.find(s=>s.key===t);if(this.needShowCylinder(t)){const s=(i==null?void 0:i.width)||0;this.onChangeToCylinder(s/2)}else this.onCancelCylinder()}onChangeToCylinder(e){this.emit(E.UPDATE_CYLINDER_STATUS,e)}onCancelCylinder(){this.emit(E.CANCEL_CURRENT_CYLINDER)}onRotaryAttachmentChange({canvasId:e,id:t,value:i,materialList:s}){var r;const a=this.data.value.get(e);if(a){const{mode:n,data:c}=a;this.onGeneralChange({canvasId:e,id:t,value:i});const o={perimeter:()=>{D(a,`data.${n}.diameter`,k(i)?null:i/p(this,v))},diameter:()=>{D(a,`data.${n}.perimeter`,k(i)?null:i*p(this,v))}};o[t]&&o[t]();const h=(r=this.getDeviceModeData(n))==null?void 0:r.processingTypes,l=this.getSupportMaterialList(h,s).find(d=>d.id===c[n].material);l&&this.speedScopeChange(e,n,!1,l)}}onGeneralChange({canvasId:e,value:t,id:i}){const s=this.data.value.get(e);if(s){const{mode:a}=s;D(s,`data.${a}.${i}`,t)}}getDeviceModeData(e){return this.processingModes.find(t=>t.value===e)||{}}getProcessTypeData(e){return this.processingTypes.find(t=>t.type===e)||{}}getSupportMaterialList(e,t){return J(e,t)}getDiameterAndRotaryAttachmentType({mode:e,generalData:t}){let i=null,s="catch";if(t){const a=t[e];a&&(i=a.diameter,s=a.rotaryAttachmentType)}return{diameter:i,rotaryAttachmentType:s}}speedChangeByMaterial(e,t,i){const s=t.find(a=>a.id===i);s&&e.displays.forEach((a,r)=>{Object.keys(a.data).forEach(n=>{Object.keys(a.data[n].parameter).forEach(c=>{var h;const o=(h=s.processingData[n])==null?void 0:h.speed;c==="official"&&a.data[n].parameter[c]&&(a.data[n].parameter[c].speed=o)})}),e.displays.set(r,D(a,"data",a.data))})}speedScopeChange(e,t,i,s){const a=this.data.value.get(e),{data:r}=a,{diameter:n,rotaryAttachmentType:c}=this.getDiameterAndRotaryAttachmentType({mode:t,generalData:r});a.displays.forEach((o,h)=>{const l=o.data;Object.keys(l).forEach(d=>{s&&i&&(s!=null&&s.processingData[d]&&r[t].material>0?(l[d].materialType="official",l[d].parameter.official={...p(this,N).processingData[d],...s.processingData[d]}):(l[d].materialType="customize",delete l[d].parameter.official)),p(this,L,x)[t]&&Object.keys(l[d].parameter).forEach(u=>{var G;const y=(G=l[d].parameter[u])==null?void 0:G.speed,T=this.calMaxSpeed({maxValue:p(this,L,x)[t][d].max,mode:t,diameter:n,rotaryAttachmentType:c});if(y>=T)l[d].parameter[u].speed=T;else if(s&&s.id&&s.processingData&&s.processingData[d]&&u==="official"){const O=s.processingData[d].speed;l[d].parameter[u].speed=Math.min(O,T)}})}),a.displays.set(h,D(o,"data",l))})}materialChangeByMode(e,t,i){var r;const s=e.mode,a=e.data[s];if(a){const{material:n,thickness:c,diameter:o,perimeter:h}=a;let l={material:0,thickness:null,diameter:null,perimeter:null};if(n===0)e.displays.forEach(d=>{Object.keys(d.data).forEach(u=>{d.data[u].materialType="customize"})});else{const d=(r=this.getDeviceModeData(t))==null?void 0:r.processingTypes,u=this.getSupportMaterialList(d,i);u.some(T=>T.id===n)&&(l={material:n,thickness:c,diameter:o||null,perimeter:h||o*p(this,v)||null}),s===ne&&this.speedChangeByMaterial(e,u,n)}D(e,"data",F({[t]:{...p(this,P)[t],...l,thickness:c,diameter:o,perimeter:h}}))}}processTypeChangeByMode(e,t){var s,a;const i=this.data.value.get(e);if(i){const r=i.mode,n=(s=this.getDeviceModeData(r))==null?void 0:s.processingTypes,c=(a=this.getDeviceModeData(t))==null?void 0:a.processingTypes;if(!te(c,n)&&c.length){const o=[];i.displays.forEach((h,l)=>{h.type!==U&&(c.some(u=>u===h.processingType)||o.push(l))}),this.onProcessingTypeChange({canvasId:e,displays:o,value:c[0]})}}}}P=new WeakMap,N=new WeakMap,m=new WeakMap,L=new WeakSet,x=function(){return V(p(this,m))?p(this,m).call(this):p(this,m)},A=new WeakMap,M=new WeakMap,S=new WeakMap,I=new WeakSet,$=function(){return V(p(this,S))?p(this,S).call(this):p(this,S)},v=new WeakMap;export{de as D};
